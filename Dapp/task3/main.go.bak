package main

import (
	"context"
	"crypto/ecdsa"
	"log"
	"math/big"
	"os"

	"github.com/ethereum/go-ethereum/accounts/abi/bind"
	"github.com/ethereum/go-ethereum/crypto"
	"github.com/ethereum/go-ethereum/ethclient"
	store "go-task/Dapp/task3/store"
)

func main() { 
	// 连接ETH节点
	client, err := ethclient.Dial("https://eth-sepolia.g.alchemy.com/v2/QFdXM7qFQqQaB-A48af2NlEeC8bZhvLe")
	if err != nil {
        log.Fatal(err)
	}
	
    // privateKey, err := crypto.GenerateKey()
    // privateKeyBytes := crypto.FromECDSA(privateKey)
    // privateKeyHex := hex.EncodeToString(privateKeyBytes)
    // fmt.Println("Private Key:", privateKeyHex)
    // 从十六进制字符串导入私钥
    privateKey, err := crypto.HexToECDSA("5e4fec68dd3d33a2cba292356c72440e2ec1b81c3fda9bbe49993edf06aea4c9")
    if err != nil {
        log.Fatal(err)
    }

    // 从私钥获取公钥
    publicKey := privateKey.Public()
    publicKeyECDSA, ok := publicKey.(*ecdsa.PublicKey)
    if !ok {
        log.Fatal("cannot assert type: publicKey is not of type *ecdsa.PublicKey")
    }

    // 获取账户地址并查询交易nonce值
    fromAddress := crypto.PubkeyToAddress(*publicKeyECDSA)
    nonce, err := client.PendingNonceAt(context.Background(), fromAddress)
    if err != nil {
        log.Fatal(err)
    }

    // 获取建议的Gas价格
    gasPrice, err := client.SuggestGasPrice(context.Background())
    if err != nil {
        log.Fatal(err)
    }
	println("gasPrice", gasPrice)

    // 获取网络链ID
    chainId, err := client.NetworkID(context.Background())
    if err != nil {
        log.Fatal(err)
    }

    // 创建带有链ID的交易授权对象
    auth, err := bind.NewKeyedTransactorWithChainID(privateKey, chainId)
    if err != nil {
        log.Fatal(err)
    }
    
    // 设置交易参数
    auth.Nonce = big.NewInt(int64(nonce))
    auth.Value = big.NewInt(0)     // in wei
    auth.GasLimit = uint64(300000) // in units
    auth.GasPrice = big.NewInt(60000000000) // gasPrice, 这里设置固定值

	// 部署合约
	address, tx, _, err := store.DeployStore(auth, client)
	if err != nil {
		log.Fatal(err)
	}

	// 保存合约地址到文件
	f, err := os.Create("contract_add_address.txt")
	if err != nil {
		log.Fatal(err)
	}
	defer f.Close()
	f.WriteString(address.Hex())

	log.Println("Contract pending deploy: ", tx.Hash().Hex())
	log.Println("Contract deployed to: ", address.Hex())

	
}